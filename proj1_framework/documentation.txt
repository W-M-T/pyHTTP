pyHTTP: a simple HTTP 1.1 webserver

INTRODUCTION:

pyHTTP is a simple HTTP 1.1 webserver written in Python 2.7 for Linux operating systems.
It is built on top of a provided framework. This framework was written in Python 2.7,
therefore we chose to continue writing code in Python 2.7. Some tests for the server are
provided in webtests.py.



RUNNING AND OPTIONS:

The server and tests can be run from command line with several optional parameters.

#running the web server
python webserver.py [-a ADDRESS] [-p PORT] [-t TIMEOUT]
#running the tests
python webtests.py [-p PORT]
Where:
   a sets the IP address the server is listening to. Default: localhost
   p sets the port. Default: 8001
   t sets the timeout in seconds (applied to all cases involving a timeout). Default: 15



CONNECTION HANDLING:

The server listens for new connections in the main thread. When a connection is made, a seperate thread is made to handle that connection.
This new thread, the connectionhandler listens for requests and sends back responses until
Either the socket times out or the connection is closed by the client. Pipelining works because the network buffer is never cleared.
Requests are parsed and handed to the responsecomposer, which, as its name suggests, composes a response based on a request.
Every response (even an error) gets the headers "Date" and "Content-Length" at the last moment before it is sent.
If a request does not use HTTP 1.1 or the "GET"-method, a corresponding error-statuscode is sent back as a response.
In case of an error-statuscode, the body of the response is the status code with its description.
If the request uses HTTP 1.1 and GET, then the following happens:
If the file is not present or cannot be accessed, a corresponding error-statuscode is sent back as a response.
If present, the conditionals If-Match and If-None-Match are checked with the etag of the requested resource.
If the resource's ETag matches none of the tags in If-Match, or it matches any of the tags in If-None-Match a
corresponding error-statuscode is sent back as a response.
In the case that no error has happened at this point, we set the headers "Content-Type", "ETag" and "Last-Modified" of the response, in accordance
with the resource.
We check the requested encodings. If the requested encoding is gzip, we check if the resource is already encoded with gzip.
In case it is not, we encode the file and set it as the response body. If it is already encoded it is directly put in the response body.
Also, the header "Content-Encoding" is set to gzip.
In case the requested encoding is not gzip and identity is allowed, the response body is set to the resource content.
If no supported encoding is accepted, a corresponding error-statuscode is sent back as a response.



STATUS CODES:

Here is a list of status codes utilized by the server, and when they are used:

* 200 OK
Sent when the request is handled without any problems.

* 304 Not Modified
Sent when one of the ETags specified in the If-None-Match header matches the etag of the requested resource.

* 404 Not Found
Sent if the requested resource was not found on the server.

* 406 Not Acceptable
Sent if none of the supported encodings (gzip and identity) are allowed according to the Accept-Encoding header.

* 412 Precondition Failed
Sent when none of the ETags specified in the If-Match header match the ETag of the requested resource.

* 500 Internal Server Error
Sent when the requested resource exists, but cannot be accessed.

* 501 Not Implemented
Sent when the request does not use the method "GET"

* 505 HTTP Version not supported
Sent when the request uses a version of HTTP that is not 1.1.



CLIENT-SIDE CACHING:

pyHTTP supports client-side caching with ETags.
The ETag of a resource can be generated by the method generate_etag() in the Resource class.
To generate an ETag the server uses os.stat() and hashlib to compute 
sha1(inode_number||last_modification_date||size_in_bytes) and then returns the hexdigest of that hash.

When ETags are added to the response, quotes ("...") are put around that digest.
When received ETags need to be compared with a generated etag the quotes are stripped from the
received ETags. The method match_etag in the Composer class is used to do this comparison.



ENCODING:

PyHTTP supports two types of encoding of the message body: gzip and identity.
Encoding/Decoding with gzip can be accomplished with the use of gzip_encode() and gzip_decode() in 
the Composer class. These two methods itself do not change the body of the message but return the
encoded / decoded version of the body. The return values is used in compose_response() in the Composer
class to change the body of the message.



CHALLENGES:

We only faced one major challenge, and one of our own making, at that.
Because we set out to make the server compatible with both python 2 and python 3 a lot of extra work had to be done.
This turned out to just be to cumbersome, as it would require us to implement certain methods twice and
everything needed to be tested as much aswell. Finally, we dropped this goal when faced with the challenge of re-encoding the
bytes generated by gzip, as it just would not work right.
One of our smaller challenges was the fact that we both developed using a different operating system, which led to some
small quirks in behaviour.



LIBRARIES USED:

The following libraries have been used:
    * gzip:         for encoding / decoding with gzip
    * stringIO:     for creating a buffer that was required for gzip encoding
    * hashlib:      for generating ETags
In addition, the following (quite) standard libraries have been used:
    * time:         for creating delays and getting the datetime
    * sys:          for getting information on a file required for ETag generation
    * mimetypes:    for guessing content type
    * theading:     for handling each connection on its own thread
    * platform:     for detecting windows
    * socket:       for networking